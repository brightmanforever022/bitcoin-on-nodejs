# 您必须知道的几个Nodejs编码习惯

## 前言

这本来应该是第一篇，但从阅读体验来说，直接上手讲理论性的东西，很突兀，我个人不太喜欢，于是有了前2篇的过度。

前面的两篇，以`sacdl`工程为例，简单介绍了Nodejs的环境搭建和代码组织。这一篇，做个简单的小结，把涉及到的编码习惯用我个人的理解，提示性的说明一下。

编程，其实就是`用特定的语言`讲故事、写规则。`特定`就是习惯，就像中国的方言，掌握了技巧，很快可以交流，剩下的细节慢慢积累就是。

比特币体现了人类去中心化的本源特质，Nodejs则是最能体现这种特质的编程语言之一，比如：一切都是数据流，事事皆回调。下面，让咱们慢慢品鉴一下：

## 一切都是数据流

流，stream，我们在第二篇讲解gulp的时候说起过。它是linux环境下的概念，与之对应的方法经常是pipe，很多书翻译成管道。我觉得，开发人员在设计这个方法的时候，应该是模拟了水流、空气流等介质的特性。如：

1、流，兼具时间和地点两个坐标，时间代表一个过程，地点代表发生、结束编码位置;
2、流，是一个时间上的线性过程，而非一个时间点。在时间段内的传输只是部分数据，若要获得完整的数据，就需要花费足够的时间;
3、流，只能沿着构建在从发生到结束的编码位置的管道传输，在传输的过程中，可以被调整和改变;

再直白一些，流，不可能一下子发生或结束，再快也得有个时间差。就像人类社会，始终以时间为单位，这一刻与下一刻，已经变化。而Nodejs严格尊重这个现实，无论是远程访问，还是本地请求，每一个data都是一个数据流，通常是Buffer对象。比如：

```
//引用模块
var fs = require('fs');
var iconv = require('iconv-lite');

var rs = fs.createReadStream('test.md');
var chunks = [], 
    size = 0;

//接受数据：一段段的接受
rs.on("data", function (chunk){
  chunks.push(chunk);
  size += chunk.length;
});

//拼接数据：并转化为utf-8的编码格式，这样就能支持包括中文，否则会乱码
rs.on("end", function() {
  var data = Buffer.concat(chunks, size);
  var str = iconv.decode(data, 'utf8');
  console.log(data);
})
```

其实，在Express的编码中，默认就是在处理buffer数据流，上面的方法照样适用。

那么，其他编程语言有什么不同吗？在很多的语言里，大家只要使用下面这一个语句

```
var rs = fs.createReadStream('test.md');
```

基本上，就相当于直接获得需要的数据了（rs == data）,后续的处理，也不需要这么做了。这样做的好处，就是更加直观，便于人类直线思考。但是处理的过程一点没有少，只不过服务器软件帮忙办了。直接的坏处就是，数据很大时，可能发生`阻塞`。非阻塞。。。

## 回调

进行中...
