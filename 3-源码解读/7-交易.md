进行中...

# 交易

## 前言

我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移，因此，加密货币的核心就是`交易`，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。

这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结一个交易的生命周期及操作流程，把我们在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。

## 源码

transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js

transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js

transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js

## 类图

![transactions-clase.png][]

## 流程图

这里把各种情况集中到一起来讨论，可以对`交易`有个全局性的把握。

![transactions-activity.png][]

## 解读

#### 关于交易



#### 亿书交易类型

目前的交易类型包括14种（但并不代表全部，下一步会有更多扩展），分别是：

```
// helpers/transaction-types.js
module.exports = {
	SEND : 0,
	SIGNATURE : 1,
	DELEGATE : 2,
	VOTE : 3,
	USERNAME : 4,
	FOLLOW : 5,
	MULTI: 6,
	DAPP: 7,
	IN_TRANSFER: 8,
	OUT_TRANSFER: 9,
	ARTICALE : 10,
	EBOOK: 11，
  BUY: 12，
	READ: 13
}
```

其中，

`SEND`是最基本的转账交易，`SIGNATURE`是上一篇提到的“签名”交易，`DELEGATE`是注册为受托人，`VOTE`是投票，`USERNAME`是注册用户，`FOLLOW`关注和添加联系人，`MULTI`是注册多重签名，`DAPP`是侧链应用，`IN_TRANSFER`是转入Aapp资金，`OUT_TRANSFER`转出Aapp资金，这些是现有版本已经完成的功能。

`ARTICALE`是发布文章，`EBOOK`是发布电子书，`BUY`是购买（电子书或其他商品），`READ`是付费阅读（电子书等，不能下载，价格由作者自由设置），这些功能会逐步添加。

#### 交易逻辑


#### 转账交易

代码实现在`modules/transactions.js`文件里，主要Api如下：

```
// 148行
router.map(shared, {
  "get /": "getTransactions",
  "get /get": "getTransaction",
  "get /unconfirmed/get": "getUnconfirmedTransaction",
  "get /unconfirmed": "getUnconfirmedTransactions",
  "put /": "addTransactions"
});

// 160行
library.network.app.use('/api/transactions', router);
```

解析一下，就是：

```
get /api/transactions/ -> shared.getTransactions
get /api/transactions/get -> shared.getTransaction
get /api/transactions/unconfirmed/get -> shared.getUnconfirmedTransaction
get /api/transactions/unconfirmed -> shared.getUnconfirmedTransactions
put /api/transactions/ -> shared.addTransactions
```

我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，`put /api/transactions/`，对应方法`shared.addTransactions`，代码如下：

```
// 652行
shared.addTransactions = function (req, cb) {
	var body = req.body;
	library.scheme.validate(body, {
		...
		},
		required: ["secret", "amount", "recipientId"]
	}, function (err) {
		if (err) {
			return cb(err[0].message);
		}

		var hash = crypto.createHash('sha256').update(body.secret, 'utf8').digest();
		var keypair = ed.MakeKeypair(hash);

		if (body.publicKey) {
			if (keypair.publicKey.toString('hex') != body.publicKey) {
				return cb("Invalid passphrase");
			}
		}

		var query = {};

		var isAddress = /^[0-9]+[L|l]$/g;
		if (isAddress.test(body.recipientId)) {
			query.address = body.recipientId;
		} else {
			query.username = body.recipientId;
		}

		library.balancesSequence.add(function (cb) {
			modules.accounts.getAccount(query, function (err, recipient) {
				if (err) {
					return cb(err.toString());
				}
				if (!recipient && query.username) {
					return cb("Recipient not found");
				}
				var recipientId = recipient ? recipient.address : body.recipientId;
				var recipientUsername = recipient ? recipient.username : null;

				if (body.multisigAccountPublicKey && body.multisigAccountPublicKey != keypair.publicKey.toString('hex')) {
					modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}

						if (!account || !account.publicKey) {
							return cb("Multisignature account not found");
						}

						if (!account.multisignatures || !account.multisignatures) {
							return cb("Account does not have multisignatures enabled");
						}

						if (account.multisignatures.indexOf(keypair.publicKey.toString('hex')) < 0) {
							return cb("Account does not belong to multisignature group");
						}

						modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {
							if (err) {
								return cb(err.toString());
							}

							if (!requester || !requester.publicKey) {
								return cb("Invalid requester");
							}

							if (requester.secondSignature && !body.secondSecret) {
								return cb("Invalid second passphrase");
							}

							if (requester.publicKey == account.publicKey) {
								return cb("Invalid requester");
							}

							var secondKeypair = null;

							if (requester.secondSignature) {
								var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
								secondKeypair = ed.MakeKeypair(secondHash);
							}

							try {
								var transaction = library.logic.transaction.create({
									type: TransactionTypes.SEND,
									amount: body.amount,
									sender: account,
									recipientId: recipientId,
									recipientUsername: recipientUsername,
									keypair: keypair,
									requester: keypair,
									secondKeypair: secondKeypair
								});
							} catch (e) {
								return cb(e.toString());
							}
							modules.transactions.receiveTransactions([transaction], cb);
						});
					});
				} else {
					modules.accounts.getAccount({publicKey: keypair.publicKey.toString('hex')}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}
						if (!account || !account.publicKey) {
							return cb("Invalid account");
						}

						if (account.secondSignature && !body.secondSecret) {
							return cb("Invalid second passphrase");
						}

						var secondKeypair = null;

						if (account.secondSignature) {
							var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
							secondKeypair = ed.MakeKeypair(secondHash);
						}

						try {
							var transaction = library.logic.transaction.create({
								type: TransactionTypes.SEND,
								amount: body.amount,
								sender: account,
								recipientId: recipientId,
								recipientUsername: recipientUsername,
								keypair: keypair,
								secondKeypair: secondKeypair
							});
						} catch (e) {
							return cb(e.toString());
						}
						modules.transactions.receiveTransactions([transaction], cb);
					});
				}
			});
		}, function (err, transaction) {
			if (err) {
				return cb(err.toString());
			}

			cb(null, {transactionId: transaction[0].id});
		});
	});
}
```

## 参考

[transactions-clase.png]: ../styles/images/modules/transactions/transactions-class.png
