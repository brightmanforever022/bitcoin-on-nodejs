进行中...

# 地址、签名与交易

## 前言

上一篇，我们专门研究了《在Nodejs中使用加密解密技术》，明白了加密解密的使用。并在讲解加密解密技术的过程中，用已经说过，亿书的帐号就是地址，而且详细阅读了地址产生的过程。但是，从开发的角度来说，远远不够，因为产生的密钥地址如何持久化到数据库？如何检索？如何用来签名？怎么实现交易的？

本篇文章，就从业务逻辑的角度，看看亿书的帐号、签名和交易是如何实现的。

## 源码

account.js https://github.com/Ebookcoin/ebookcoin/blob/master/logic/account.js

accounts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/accounts.js

contacts.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/contacts.js


signatures.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/signatures.js


transactions.js https://github.com/Ebookcoin/ebookcoin/blob/master/modules/transactions.js

transaction.js https://github.com/Ebookcoin/ebookcoin/blob/master/logic/transaction.js

transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/transaction-types.js

## 1.别名地址

计算机软件是人类活动的模拟和程序化，也就是大家所谓的“虚拟化”。在设计的时候，都会设想一个角色（Role）代替人类，负责完成要开发的各类操作。这个角色，通常在开发中被定义为用户（User），用户看到并可操作的就是用户帐号，在此基础上，才能进行权限认证，记录和管理与用户有关的各类操作。

比特币里的用户角色仅仅就是一个比特币地址，而因为真实网络的复杂性，对于IP的追踪也不容易，所以说比特币的匿名性很好（因为压根就没有给你暴露名字的机会）。亿书，要做版权保护的应用，如果再进行完全的匿名操作，显然有点不合适，属于跟自己过不去。同时，复杂的字符串地址也不适合人类脑记，不方便与他人协作和交互，因此亿书给出了“别名地址”的功能，并对“社交功能”进行了强化。相见 [亿书白皮书][] 。

具体操作时，可以实现下面的需求：

1. 用户可以注册一个用户名，它相当于是用户帐户的一个别名。类似于人们常用的支付宝帐号，其它用户可以直接向该用户的用户名付款，用户不再需要记下一长串的加密货币地址;
2. 用户名都是唯一的;
3. 注册后无法更改或删除;
4. 用户可以维护一个联系人列表;

这些操作和信息，都可以在客户端里完成，如下图所示：

![wallet-username][]

## 类图

## 流程图

## 解读

#### 1.数据库结构

保存用户信息的表是`mem_accounts`，主要包含字段：

```
username，isDelegate，u_isDelegate，secondSignature，u_secondSignature，u_username，address，publicKey，secondPublicKey，balance，u_balance，vote，rate，delegates，contacts，followers，u_delegates，u_contacts，u_followers，multisignatures，u_multisignatures，multimin，u_multimin，multilifetime，u_multilifetime，blockId，nameexist，u_nameexist，producedblocks，missedblocks，virgin，fees，rewards
```

操作数据库的代码在`logic/account.js`里，

#### 2.分析Api

看 `modules/accounts.js` 368行的代码， 如下：

```
// 368行
router.map(shared, {
  "post /open": "open",
  "get /getBalance": "getBalance",
  "get /getPublicKey": "getPublickey",
  "post /generatePublicKey": "generatePublickey",
  "get /delegates": "getDelegates",
  "get /delegates/fee": "getDelegatesFee",
  "put /delegates": "addDelegates",
  "get /username/get": "getUsername",
  "get /username/fee": "getUsernameFee",
  "put /username": "addUsername",
  "get /": "getAccount"
});

// 439行
library.network.app.use('/api/accounts', router);
```

前面，我们分析过，这里的router是`helpers/router.js`的一个实例。上述代码，最终会在439行的调用中，映射为公共Api，并分别对应`shared`中的方法，如：

```
// accounts
get /api/accounts/ -> shared.getAccount //帐号主页

post /api/accounts/open -> shared.open //登录
get /api/accounts/getBalance -> shared.getBalance
get /api/accounts/getPublicKey -> shared.getPublickey
post /api/accounts/generatePublicKey -> shared.generatePublickey

// username
get /api/accounts/username/get -> shared.getUsername
get /api/accounts/username/fee -> shared.getUsernameFee
put /api/accounts/username -> shared.addUsername //注册用户名

// delegates
get /api/accounts/delegates -> shared.getDelegates
get /api/accounts/delegates/fee -> shared.getDelegatesFee
put /api/accounts/delegates -> shared.addDelegates

// count 对应431行单独定义
get /api/accounts/count -> private.accounts

// 另外两个是在debug或top环境下调试用的，暂且不表。
...
```

这里的`delegates`（受托人）api，以及后面的debug环境下的api，暂且不提。通盘浏览这些公开接口信息，我们知道，可以直接浏览的信息主要包括余额（balance)、公钥（publicKey)、用户名（username）及修改需要花费的费用（fee），以及受托人及其费用等，可以产生公钥，可以添加用户名。但是，没有删除和修改用户名的接口功能。

对照上面的需求，我们还需要明白，如何做到用户名唯一的，以及如何作为支付地址功能的，这就需要进一步参看源代码。

#### 3.注册用户名

从上面的Api，很容易找到“注册用户名”的源码`shared.addUsername`，如下：

```
// 868行
shared.addUsername = function (req, cb) {
	var body = req.body;
	library.scheme.validate(body, {
		type: "object",
		properties: {
			secret: {
				type: "string",
				minLength: 1
			},
			publicKey: {
				type: "string",
				format: "publicKey"
			},
			secondSecret: {
				type: "string",
				minLength: 1
			},
			username: {
				type: "string",
				minLength: 1
			}
		},

    // 890行
		required: ['secret', 'username']
	}, function (err) {
	  // 896行
		var hash = crypto.createHash('sha256').update(body.secret, 'utf8').digest();
		var keypair = ed.MakeKeypair(hash);

		if (body.publicKey) {
			if (keypair.publicKey.toString('hex') != body.publicKey) {
				return cb("Invalid passphrase");
			}
		}

		library.balancesSequence.add(function (cb) {
			if (body.multisigAccountPublicKey && body.multisigAccountPublicKey != keypair.publicKey.toString('hex')) {
				modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {
					if (err) {
						return cb(err.toString());
					}

					if (!account || !account.publicKey) {
						return cb("Multisignature account not found");
					}

					if (!account.multisignatures || !account.multisignatures) {
						return cb("Account does not have multisignatures enabled");
					}

					if (account.multisignatures.indexOf(keypair.publicKey.toString('hex')) < 0) {
						return cb("Account does not belong to multisignature group");
					}

					modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {
						if (err) {
							return cb(err.toString());
						}

						if (!requester || !requester.publicKey) {
							return cb("Invalid requester");
						}

						if (requester.secondSignature && !body.secondSecret) {
							return cb("Invalid second passphrase");
						}

						if (requester.publicKey == account.publicKey) {
							return cb("Incorrect requester");
						}

						var secondKeypair = null;

						if (requester.secondSignature) {
							var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
							secondKeypair = ed.MakeKeypair(secondHash);
						}

						try {
							var transaction = library.logic.transaction.create({
								type: TransactionTypes.USERNAME,
								username: body.username,
								sender: account,
								keypair: keypair,
								secondKeypair: secondKeypair,
								requester: keypair
							});
						} catch (e) {
							return cb(e.toString());
						}
						modules.transactions.receiveTransactions([transaction], cb);
					});
				});
			} else {
				self.getAccount({publicKey: keypair.publicKey.toString('hex')}, function (err, account) {
					if (err) {
						return cb(err.toString());
					}
					if (!account || !account.publicKey) {
						return cb("Invalid account");
					}

					if (account.secondSignature && !body.secondSecret) {
						return cb("Invalid second passphrase");
					}

					var secondKeypair = null;

					if (account.secondSignature) {
						var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
						secondKeypair = ed.MakeKeypair(secondHash);
					}

					try {
						var transaction = library.logic.transaction.create({
							type: TransactionTypes.USERNAME,
							username: body.username,
							sender: account,
							keypair: keypair,
							secondKeypair: secondKeypair
						});
					} catch (e) {
						return cb(e.toString());
					}
					modules.transactions.receiveTransactions([transaction], cb);
				});
			}

		}, function (err, transaction) {
			if (err) {
				return cb(err.toString());
			}

			cb(null, {transaction: transaction[0]});
		});
	});
};
```

## 总结

## 链接

## 参考

[亿书白皮书]: http://ebookchain.org/ebookchain.pdf

[wallet-username]: ../wallet-username.jpg
