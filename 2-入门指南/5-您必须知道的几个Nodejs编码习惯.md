# 您必须知道的几个Nodejs编码习惯

## 前言

这本来应该是第一篇，但从阅读体验来说，直接上手讲理论性的东西，很突兀，我个人不太喜欢，于是有了前2篇的过度。

前面的两篇，以`sacdl`工程为例，简单介绍了Nodejs的环境搭建和代码组织。这一篇，做个简单的小结，把涉及到的编码习惯用我个人的理解，提示性的说明一下。

编程，其实就是`用特定的语言`讲故事、写规则。`特定`就是习惯，就像中国的方言，掌握了技巧，很快可以交流，剩下的细节慢慢积累就是。

比特币体现了人类去中心化的本质，Nodejs则是最能体现这种特质的编程语言之一，比如：一切都是数据流，事事皆回调。下面，让咱们慢慢品鉴一下：

## 1.一切都是数据流

#### 概念理解

`Nodejs`默认提供了`Stream`模块，即：流，我们在第二篇讲解gulp的时候说起过。作为一个抽象接口，它是Nodejs的基础模块，被其他很多模块所使用。

流，最早是linux环境下的概念，与之对应的方法经常是pipe，即：管道（方法）。我觉得，这种设计非常形象合理。流的概念存在于人类生活的任何场景，数据流，与水流、空气流等具有相同的特性。如：

1、流，兼具时间和地点两个坐标，时间代表一个过程，地点代表发生、结束编码位置;

2、流，是一个时间上的线性过程，而非一个时间点。在时间段内的传输只是部分数据，若要获得完整的数据，就需要花费足够的时间;

3、流，只能沿着构建在从发生到结束的编码位置的管道传输，在传输的过程中，可以被调整和改变;

再直白一些，流，不可能一下子发生或结束，再快也得有个时间差。就像人类社会，始终以时间为单位，这一刻到下一刻，已经发生变化。而Nodejs严格尊重这个现实，无论是远程访问，还是本地请求，每一个data都被分成一段一段数据流（即Buffer对象）传输。

因此，Nodejs里没有简单拷贝的概念，或者说拷贝其实可以通过流来简单实现。

#### 代码示例

比如：

```
//引用模块
var fs = require('fs');
var iconv = require('iconv-lite');

var rs = fs.createReadStream('test.md');
var chunks = [], 
    size = 0;

//接受数据：一段段的接受
rs.on("data", function (chunk){
  chunks.push(chunk);
  size += chunk.length;
});

//拼接数据：并转化为utf-8的编码格式，这样就能支持包括中文，否则会乱码
rs.on("end", function() {
  var data = Buffer.concat(chunks, size);
  var str = iconv.decode(data, 'utf8');
  console.log(data);
})
```

其实，在Express的编码中，默认也是在处理buffer数据流，上面的方法照样适用。

#### 思维习惯

记住，在Nodejs的世界里，无论是处理文件，还是请求远程资源，处理的就是“数据流”，处理方法都是如此。为了直观，还是用第二篇里那张`管道`图吧：

![pipe][]

**进一步**：因为任何`流`都是时间的函数，为了节省时间、提高效率，最好的方式，当然是`并行`处理。也就是说每一个`流`最好使用一个独立的线程，而不影响其他的。事实上，Nodejs就是这么处理的，这就是下面要说的`回调`。看看上面的代码形式，就是典型的`回调`用法。

## 2.事事皆回调

#### 概念理解

中文`回调`这个词，总不能让人一下子就理解得那么透亮。其实，如果按英文`callback`直译最好，`调回`虽然直白，但好理解。

“事事皆回调”，是不是有点绝对？其实不然，它贯穿在人类沟通交往的全过程。大到工程项目，小到求助问路，只要是你必须或需要别人帮你干的事，你就得用到`回调`，即：让他人完成并获得明确的回应。你让别人为你做某件事，这叫事件触发;你给一个方法获得该事结束后的结果，这就是`回调`。

典型的示例就是，你是一位老板，很多事情需要下属去做，然后你获得结果。如果下属合格，你安排下去的事情，他（她）一定会按照要求给你回应，即便没有达到预期的结果，聪明的下属也会及时向你回报进展。但普篇存在的现象是，老板安排的很多事情并不能得到及时回应，这时候你就得亲自过问，要不打电话、要不派秘书或办公室人员去追踪，总之，要有一条`通信线路`让你得到回馈（无论好坏）。

这里，优秀员工主动汇报工作的行为，以及老板打电话或派人的行为，都是回调。很容易想象，假如没有这些`回调`，我们还能做成什么事，世界会是什么样。一些国字号的企业，为什么效率如此低下？几个人干着其他公司一个人的活？社会批评的懒散，是不干活吗？不尽然，其中大部分是不给你`回调`（或者给你不明确的`回调`）。

因此，一个优秀的老板，一定是一个会选人、用人和培养人的人，如果员工只知道埋头干活，不知道及时反馈进展，老板一定会有自己的招式应对;一个优秀的员工，一定是一个让老板节省脑力的人，事前、事中、事后都会适时回报情况。总之，只要想做事、做成事，组织会自觉对彼此间的`回调`的方法进行优化，降低沟通成本，提高效率。

具体到Nodejs的程序，主线程就是老板，子线程就是员工，而`回调`就是它们之间的通信方法。使用`回调`的代码，我们称为`异步`编程。说白了，就是你干自己擅长的、份内的事，其他的都交给别人去做（即异步），事实上大家都在`同步`做事情。

#### 代码示例

具体形式，在前面的文章中用过多次了，这里再举个例子，类比一下：

(1)在前端开发时，我们用ｄ3.js请求数据的代码如下：

```
ｄ3.json('/resource.json', function(err, data){
   //code
   console.log("Hello, ", data);
});

console.log("I`m end.");
```

这里，我们请求的`/resource.json`，其实就是远程服务器上的资源`http://localohost:3000/resource.json`，后面紧跟的函数就是｀回调｀函数，要在资源请求结束之后，才会调用。所以，｀Hello，...`必然要出现在`I'm end.`之后。

(2)在后台开发时，我们也有与之几乎一样的代码：

```
var fs = requrie('fs');
fs.readFoile('/resource.json', function(err, data){
   //code
   console.log("Hello, ", data);
});

console.log("I`m end.");
```

这里，我们请求的`/resource.json`，其实就是本地的资源`resource.json`文件，后面紧跟的函数也是`回调`函数，同样要在资源请求结束之后，才会调用。所以，｀Hello，...`也会出现在`I'm end.`之后。

#### 思维习惯

在Nodejs的世界，到处是`回调`（多数使用callback、next、cb等命名回调函数），到处是`异步`，当你不自觉的编写了下面的代码，而反复调试，得不到`data`预期的结果时，要意识到，您已掉进了`异步`的陷阱，忘记了`回调`。

```
var fs = requrie('fs');
var data = fs.readFile('/resource.json'); //异步方法

//code
console.log("Hello, ", data);

console.log("I`m end.");

```

当然，可以这样修改上面的错误代码：

```
var data = fs.readFileSync('/resource.json'); //同步方法
```

在很多其他编程语言里，就是这么用的。这样做的好处，就是直观，便于人类直线思考。坏处就是，数据（流）很大时，需要长时间执行，直接`阻塞`进程，整个程序只好停下来等着，这就是`I/O阻塞`。nodejs因为用了`回调`，所以叫`I/O非阻塞`。

**进一步**：既然“事事皆回调”，那么`回调`里面也可能有`回调`，事实上，这种情况非常多。这也是很多人对Nodejs畏惧的原因之一，多年的高手也经常栽在上面，于是大家总结有`回调大坑`的说法，就是回调嵌套太多，流程复杂，难以驾驭。

不过，大家也提供了很多方案，比如：Async,promise等流程化组件，就能很好的解决这个问题。具体细节，后面在阅读代码时，我们再说。这里，我们说说程序异常（错误）的处理，从函数编程的角度去理解。

## 3.异常要捕捉

#### 概念理解

单进程让异常处理显得非常重要。系统级和程序级错误，用户级异常（密码不正确等）

#### 处理方法

`domain`模块的使用; connect的两种err处理（函数式编程）。


进行中...

## 参考

nodejs中流(stream)的理解：http://segmentfault.com/a/1190000000519006
Linux管道PIPE的原理和应用: https://www.hitoy.org/pipe-aplication-in-linux.html

[pipe]: ../assets/images/2/pipe.png
