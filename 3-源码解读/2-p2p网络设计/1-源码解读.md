进行中...

# P2P网络设计

从这篇开始，将使用 [Ebookcoin][] 的代码来继续进行分析并开发。这是我2016年正式发起的一个开源项目，基于Crypti最新版和非常宽松的MIT协议，大家可以先看看这篇文章 [电子书出版与版权保护系统][] 了解一下，更多信息会在适当的时候公布。

## 前言

加密货币都是去中心化的应用，去中心化的基础就是P2P网络。可以说，简单、实用、健壮的点对点网络是加密货币的基础之一，无可替代。

这一篇，我们就来看看Ebookcoin的点对点网络是如何实现的。

## 源码

涉及到的源码，地址如下：

peer.js: https://github.com/Ebookcoin/ebookcoin/blob/master/modules/peer.js

router.js: https://github.com/Ebookcoin/ebookcoin/blob/master/helpers/router.js

## 类图

每一个模块都是一个js class，因此该类图较为简单。

![peer-class.png][]

这里使用流程图较为合适。

## 解读

目前，分析的是`modules`文件夹下的各个模块文件，这些模块基本都可以理解为独立的Express微应用，在开发和设计上相互独立。

####（1）路由设计

任何应用，只要提供Web访问能力或第三方访问的Api，都需要提供从地址到逻辑的请求分发功能，这就是路由。Ebookcoin是基于http协议的Express应用，Express底层基于Nodejs的connect模块，因此其路由设计简单而灵活，这里就是一个非常好的例子。

前面，在入门部分，已经讲到对路由的分拆调用，这里提供了另一种扩展形式。先看看`helper/router.js`吧。

```
// 27行
var Router = function () {
	var router = require('express').Router();

	router.use(function (req, res, next) {
		res.header("Access-Control-Allow-Origin", "*");
		res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
		next();
	});

	router.map = map;

	return router;
}
...
```

这段代码定义了一个Express路由器`Router`，并扩展了两个功能：

* 允许任何客户端调用。其实，就是设置了跨域请求，选项`Access-Control-Allow-Origin`设置为`*`，自然任何IP和端口的节点都可以访问和被访问。
* 添加了地址映射方法。该方法的主要内容如下：

```
// 3行
function map(root, config) {
	var router = this;
	Object.keys(config).forEach(function (params) {
		var route = params.split(" ");
		if (route.length != 2 || ["post", "get", "put"].indexOf(route[0]) == -1) {
			throw Error("wrong map config");
		}
		router[route[0]](route[1], function (req, res, next) {
			root[config[params]]({"body": route[0] == "get" ? req.query : req.body}, function (err, response) {
				if (err) {
					res.json({"success": false, "error": err});
				} else {
					return res.json(extend({}, {"success": true}, response));
				}
			});
		});
	});
}
```

该方法，接受一个根路由地址root和一个映射设置config作为参数，功能就是将config下的各个路由加载到root上。我们知道，Express提供了所谓轻应用的功能，即:将某一个模块路由集中加载到某一个地址上，这个地址可能有前缀。

开发中，只要按照Express单独应用的逻辑开发就行，路由加载的时候，再设置路由前缀，比如：`/admin`。这样，一个应用可以拆分为几个应用开发，各不冲突，逻辑清晰。这里的`map`函数就是这种加载功能的简单扩展实现。

如此以来，`modules`下的诸多模块都是一个独立的小应用。这为我们学习分析，特别是开发，提供了简单高效的思路。

扩展一下，使用的ruby on rails等开发语言的小盆友，习惯集中进行路由设计，用一个`router.rb`文件保存整个应用的路由。参考这个函数，Nodejs的应用也很容易实现单独路由文件设计。

####（2）注册路由

从Api设计的角度考虑，路由

上面在查询的时候，最后都要从sqlite数据库里查询数据表`peers`，不过因为简单。

#### 3.加载节点

大多数应用，读数据基本上是没有什么难度的事情，难在写数据。上面分析的代码，都是`get`请求，可以查寻节点及其信息。我们自然会问，初始的节点在哪里？节点变更了，怎么办？

（1）初始化节点

从现实角度考虑，在一个P2P网络中，一个孤立的节点，在没有其他任何节点信息的情况下，仅仅靠网络扫描去寻找其他节点，将是一件很难完成的事情，更别提高效和安全了。

因此，在运行软件之前，都已经初始化一些节点供联网使用，是最简单直接的解决方案。这个在配置文件`config.json`里，有直接体现：

```
// config.json 15行
"peers": {
		"list": [],
		"blackList": [],
		"options": {
				"timeout": 4000
		}
},
...
```

list的数据格式为：

```
[
	{
		ip: 0.0.0.0,
		port: 7000
	},
	...
]
```

当然，也可以在启动的时候，通过参数`--peers 1.2.3.4:70001,2.1.2.3:7002`提供（代码见`app.js`47行），不然，就是空的。在测试环境下，可以使用上面的地址请求获得空节点列表。

（2）写入节点

写入节点，就是持久化，或者保存到数据库，或者保存到某个文件。这里保存到sqlite3数据库里了，代码如下：

```
// peer.js 347行
Peer.prototype.onBlockchainReady = function () {
	async.eachSeries(library.config.peers.list, function (peer, cb) {
		library.dbLite.query("INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)", {
			ip: ip.toLong(peer.ip),
			port: peer.port,
			state: 2,
			sharePort: Number(true)
		}, cb);
	}, function (err) {
		if (err) {
			library.logger.error('onBlockchainReady', err);
		}

		private.count(function (err, count) {
			if (count) {
				private.updatePeerList(function (err) {
					err && library.logger.error('updatePeerList', err);
					library.bus.message('peerReady');
				})
				library.logger.info('Peers ready, stored ' + count);
			} else {
				library.logger.warn('Peers list is empty');
			}
		});
	});
}
```

这段代码的意思是，当区块链（后面篇章分析）加载完毕的时候（触发事件），依次将配置的节点写入数据库（如果数据库已经存在相同的记录就忽略），然后更新节点列表，触发节点加载完毕事件，从而进入循环更新节点状态。

这里对数据库`Sqlite`的插入操作，插入语句是`library.dbLite.query("INSERT OR IGNORE INTO peers`，有意思的是`IGNORE`字符串，是sqlite3支持的，当数据库有相同记录的时候，该记录被忽略，继续往下执行。

执行成功，就会调用`library.bus.message('peerReady')`，进而触发`onPeerReady`事件,该事件函数如下：

```
// peer.js 374行
Peer.prototype.onPeerReady = function () {
	setImmediate(function nextUpdatePeerList() {
		private.updatePeerList(function (err) {
			err && library.logger.error('updatePeerList timer', err);
			setTimeout(nextUpdatePeerList, 60 * 1000);
		})
	});

	setImmediate(function nextBanManager() {
		private.banManager(function (err) {
			err && library.logger.error('banManager timer', err);
			setTimeout(nextBanManager, 65 * 1000)
		});
	});
}
```

两个`setImmediate`函数，一个循环更新列表，一个循环更新节点状态。

```
// 
private.banManager = function (cb) {
	library.dbLite.query("UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now < 0)", {now: Date.now()}, cb);
}
```



（3）更新节点


[Ebookcoin]: https://github.com/Ebookcoin/ebookcoin
[peer-class.png]: ../
