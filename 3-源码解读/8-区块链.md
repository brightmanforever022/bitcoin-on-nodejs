进行中...

# 区块链

## 前言

比特币诞生以来，经过7个年头的发展，加密货币从小众的玩具，到世界各国的围追堵截，再到今天各大公司的参与和追捧，其中最令各国恐惧阻挠的原因是区块链，最令人神往的也是因为区块链。同样，为什么要写这本书，为什么要把版权保护和知识分享建立去中心化的架构之上，原因还是区块链。

我们分享的源码项目——亿书，是一款加密货币产品，用时髦的话说，更是一款实用的区块链产品。那么，区块链是什么？有那些非比寻常的特点？这一章，我们就来详细解释和说明，并把亿书相关的代码逻辑，认真阅读和理解，以便更加深入的了解和掌握这项技术。

## 源码

blocks.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/blocks.js

block.js https://github.com/Ebookcoin/ebookcoin/blob/logic/block.js

loader.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/loader.js

## 类图

![blocks-class.png][]

## 流程图

![blocks-activity.png][]

## 解读

#### 1.区块链是什么？

区块链是去中心化的公共账本，是一种由包含交易信息的记录从后向前有序链接起来的数据结构，可以存储成文件形式，不过多数产品存储在一个数据库中，比如比特币使用Google的LevelDB数据库存储。

（1）从数据库设计角度理解区块链

用数据库的概念理解，区块链就是一张“自引用”的数据库表。每条记录代表一个区块，这条记录（区块）记录着它前面（时间上）一条记录的信息，可以直接查询到前一条记录，因此从任何一条记录开始都可以往前顺序追溯，直到第一条记录。普通自引用表结构，通常使用ID作为关联外键，加密货币使用的是经过加密处理的信息字段，称为区块头信息，具有签名认证作用，可实现自我验证，防止被篡改。

与区块链直接关联的另一张重要的表，就是交易表。加密货币包含大量的交易，我们之前分析过，交易可以是加密货币，也可以是债权、股权或版权等各类数字资产，这些交易保存在一张独立表里，并与区块链形成多对一的关联方式。如此以来，只要追溯到区块，就很容易查询到该区块包含的交易记录。这样一个公开透明、无法篡改、方便追溯的账本就形成了。

上面是从数据库查询的角度，也就是读数据角度考虑的，如果从写入的角度思考，就更有意思了。写入是要根据需求不同进行不同的编码，我们前面说过，加密货币的各种功能都可以通过扩展交易类型进行编码，如果把一些现实中的合同规则进行编码，要求系统在某个条件下自动执行（写入或更新）某交易，自然也是件简单轻松的事情，这就是“智能合约”的简单理解。

我们在第一部分提到过“智能合约”的概念，在这里再次提及，作为程序员能够更加直观的去理解编码上的可行性。“智能合约”也是目前加密货币社区讨论火热的概念，绝不仅仅是这里提到的简单的概念，可以发挥你想象的翅膀，从加密货币扩展到现实世界的各种场景，比如：自动贩卖机、销售终端、大公司间的电子数据交换和银行间用于转移和清算的支付网络，以及音乐、电影和电子书等数字版权交易等。

（2）形象化理解区块链

人们通常把具有先后顺序的数据结构，使用栈来表示，比特币白皮书把这种结构进一步形象化，第一个区块作为栈底，然后其他区块按照时间顺序依次堆叠在上面，这样一来，区块与首区块之间的距离就表示“高度”，“顶端”就表示最新添加的区块。每个区块包含大量交易，就是包含在对应栈里的数据。于是，一个区块链就象下面这样：

![stack-drawers.png][]

这里，区块链就像一个大大的橱柜，区块就是其中一个抽屉，每个抽屉里是满满的交易。

（3）区块链分叉

**物理分叉**。每一个区块都与它的前一区块（父区块）关联，而对它后面的区块（子区块）无限制，也就是说最顶端的区块，肯定知道它的父区块（已经写入区块链），但不知道子区块（或许还没有产生，也可能在传输的过程中）。我们知道，从物理层面，数据库、硬盘、网络的IO操作是最耗费时间成本的，在某一个时刻，多个最新区块同时找到父区块是很常见的现象，这就必然导致区块链分叉（从主链向多个方向发展）。这种情况，是在同一个软件版本的情况下，没有人为干预，不妨叫做物理分叉。

显然，物理分叉取决于物理环境，这与什么样的共识机制没有直接关系，不论是采取工作量证明机制（PoW)的比特币、还是采取股权证明机制（PoS）的点点币，亦或是这里采取授权股权证明机制（DPoS）的亿书币，都是如此。为了保持区块链的单一链条，解决分叉的最简单方式就是放任每个分叉继续增长，通常在下一刻就会出现差别，这时候软件选择最长的那个链条作为主链即可。在具体的设计开发过程中，这也是一个逻辑相对复杂的难点。

**人为分叉**。那么，如果存在人的干预，会怎么样呢？我们知道，世界上没有绝对完美无缺的东西，人类开发设计的软件也不例外。而且，人类的需求是在变化的，软件要不断推出新功能来应对，不然早晚会被用户抛弃。所以，软件出现漏洞，或者添加新的功能，这类情况是再正常不过的事情。看看微软的windows系统，时不时跳出来的漏洞修复提醒就知道这类事情多么常见。这时候，旧版本的软件对新版本软件产生的区块可能出现兼容性问题，甚至需要人为改变区块链的走向，这就导致分叉行为，不妨叫做人为分叉。

很显然，人为分叉也是无法避免的事情。你可能认为很简单，有漏洞就修复吧，有新功能加上就得了，有什么好解释的。事实上，加密货币核心是交易，是价值转移的手段，规则的改变直接关系到所有持币人的利益。我们在第一部分说过，人是趋利的，要追求利益最大化，新功能能否保护用户的利益，还是代表了少部分利益集团的意志，应该如何约束和决策，这已经不单单是一个技术问题，更多的是政治问题，需要社区共同参与。历史证明，承载了较大资金盘的加密货币，在某一次分叉过程中，个别用户或矿工没有及时更新软件，就造成了直接经济损失。所以，每一个持币用户都非常关心任何一次分叉行为，如果需要，都有可能站出来表达自己的意愿。

**硬分叉和软分叉**。它们都属于人为分叉，孰优孰劣也是当前社区分歧比较严重的问题。最初，社区区分这两个概念的简单方法就是，“硬分叉”是与旧版本的兼容度不高，但是获得了社区共识的规则明确的分叉行为，“软分叉”恰恰相反。发展到今天，只要是明确的“分叉”行为，大家都会寻求社区共识，所以二者的区别主要集中在软件兼容问题上了。这里的社区共识，是指包括软件开发者、矿工和使用者在内的整个软件社区，采取投票等方式，获得最大程度的一致性意见，通常是90%以上的社区成员同意就认为是达成了社区共识。比如最近以太坊为了应对The Dao遭受黑客攻击而实施的紧急硬分叉，就获得了社区87%的同意（接近90%）。

从技术角度讲，这里所谓的“硬”，主要体现在与旧版本的不兼容（或少量兼容）上，属于抛弃旧版本的行为，如果用户不升级软件，一定会带来直接损失，感觉上更加强硬得多。“软分叉”，最大程度的保持了对以前版本的兼容性，做得好的话，多个版本可以同时运行，类似于正常的版本迭代升级，用户可以自由选择是否升级。有人说“硬分叉”是很糟糕的事情，另一些人认为“软分叉”风险更大。从历史来看，比特币经历过很多次“硬分叉”和“软分叉”，依然安全和坚挺。事实证明，只要准备充分，操作得当，无论是“硬分叉”，还是“软分叉”，都不可怕，只不过“软分叉”在编码中需要考虑的情况更加复杂，出现Bug的可能性更高，对用户的影响较为隐蔽，风险反而更大一些。

我个人不喜欢谈政治，但是作为交易媒介的新兴产物——加密货币，天生就是政治的附属品，各种法币大家不会怀疑，比特币和各种竞争币也是如此。这些货币的持续发展，往往是不同利益团体（至少包括开发者、矿工和用户）之间不断博弈的结果。最初是开发者主导，某个时期矿工的力量更加强大，后期用户的力量就不容忽视。也正是这些力量之间的制衡，才让加密货币相对持续稳健的发展，当这三种力量达到均衡的时候，就是这个加密货币相对成熟的时候。最近，以太坊硬分叉成功处理Dao遭受的黑客攻击事件，搅动了整个加密货币社区，不同利益者发出不同的声音，这是好事，充分说明加密货币仍处在初级阶段，还有很长的路要走。

#### 2.区块链的特点

我们可以按照堆栈的方式理解数据结构，并采用自引用的关联方式设计数据库模型，但是做到这些，我个人认为并不代表就是区块链了，它还必须被置于去中心化的网络，由P2P网络节点共同维护，才能称得上区块链。当然，也有人持不同观点，他们认为一个中心化的应用，如果使用类似的数据结构，会更加安全（比不使用该结构的中心化系统），同时可以避免分叉，性能或许更高（比去中心化的系统），但事实上没有了P2P网络的支撑，这点改进算不上什么。我们之前分析过，P2P网络本身就是一条非常好的安全屏障，单点被攻击或被破解，对整个网络系统没有太大伤害，而任何中心化的系统仅仅相当于单节点，安全性大大降低。所以，为了那些许的性能改进，却要牺牲更好的安全性，有点得不偿失。

汇总以上信息，区块链应该具备这样几个特点：

* 分布存储：区块链处于P2P网络之中，无论什么公链、私链，还是联盟链，都要采取分布式存储，使用一种机制保证区块链的同步和统一;
* 公开透明：每个节点都有一个数据库副本，数据可以任意查询;
* 无法篡改：每一区块都会记录前一区块的加密区块头信息，并实现追溯和验证，确保无法篡改;
* 存在分叉：这是由P2P网络等物理环境，以及软件开发实践过程决定的，人们无法根本性杜绝。

也正是因为这样的特点，区块链的概念才逐渐火爆起来。与加密货币的概念相比，区块链这个名字抛开了代币的概念，更加形象化、技术化、去政治化，更适合作为一门技术去研究、去推广。实践证明，区块链技术能实现一切中心化应用的场景，可以解决（或更好的解决）很多中心化应用无法解决的问题，比如分布式财务管理、分布式存储、知识产权保护、电子商务，乃至物联网，特别是对于金融业而言，资金清算、审计等等，成本会大幅度降低。亿书，就是利用它公开透明、可追溯的特点，与数字出版结合起来，实现自媒体和版权保护，彻底解决当前数字出版版权保护不力的顽疾。

#### 3.区块链开发应该解决的问题

明白区块链基本原理之后，就可以着手设计其基本功能了。从需求的角度说，设计中需要做到如下几点：

（1）同步区块链。确保节点与其他节点的区块链一致：

* 保存创世区块
* 同步区块;
* 验证区块；

（2）处理新区块。同步后，该节点就可以处理网络中的交易了：

* 处理区块头信息，并产生区块；
* 收集整理交易，写入（关联）区块；
* 把新产生的区块写入区块链；
* 解决区块链分叉。

下面，我们从数据库设计出发，认真讨论亿书区款链是如何运作的。

#### 4.亿书区块链数据库设计

亿书使用SQLite数据库，与区块链相关的数据库结构如图：

![blocks-database.png][]

blocks表是区块链，trs表是各种交易，forks_stat表代表分叉状态。从关联关系上看，blocks首先是一个自引用表，使用previousBlock关联；与trs是一对多的关系，一条记录关联多条交易；与forks_stat也是一对多的关系，意思是有分叉。

#### 5.亿书区块链逻辑实现

这里按照上面提到的开发区块链要解决的问题，逐一对照，查看亿书技术实现。

（1）保存创世区块

创世区块是硬编码到客户端程序里的，会在客户端运行的时候，自动直接写入数据库。这样做的好处是保证每个客户端都有一个安全、可信的区块链的根。

```
// modules/blocks.js
// 78行
function Blocks(cb, scope) {
	library = scope;
	// 80行
	genesisblock = library.genesisblock;
	self = this;
	self.__private = private;
	private.attachApi();

	// 85行
	private.saveGenesisBlock(function (err) {
		setImmediate(cb, err, self);
	});
}
```

这是`modules/blocks.js`模块的结构函数，在入口程序`app.js`运行的时候，直接创建实例，因而在程序启动时，85行的代码`private.saveGenesisBlock`方法直接运行。如果已经运行过，该方法就会返回，什么都不做。如果第一次运行，该方法就会直接保存创世区块（80行的genesisblock），接着调用源文件266行的`private.saveBlock`方法（不再粘贴），把创世区块记录（包括交易）保存到数据库。

这是一个非常典型的区块创建过程，我们可以借机会看看一个区块（创世）的数据是什么样的：

```
// genesisBlock.json 文件
{
  "version": 0,

	// 3行
  "totalAmount": 10000000000000000,  
  "totalFee": 0,
  "reward": 0,
  "payloadHash": "1cedb278bd64b910c2d4b91339bc3747960b9e0acf4a7cda8ec217c558f429ad",
  "timestamp": 0,
  "numberOfTransactions": 103,
  "payloadLength": 20326,
  "previousBlock": null,
  "generatorPublicKey": "b7b46c08c24d0f91df5387f84b068ec67b8bfff8f7f4762631894fce4aff6c75",

	// 1757行
  "height": 1,
  "blockSignature": "2985d896becdb91c283cc2366c4a387a257b7d4751f995a81eae3aa705bc24fdb950c3afbed833e7d37a0a18074da461d68d74a3a223bc5f8e9c1fed2f3fec0e",
  "id": "8593810399212843182"，

	// 12行。为了方便阅读，这里把关联的交易信息排版在最后位置
	"transactions": [
    {
      "type": 0,

			// 15行
      "amount": 10000000000000000,
      "fee": 0,
      "timestamp": 0,
      "recipientId": "6722322622037743544L",
      "senderId": "5231662701023218905L",
      "senderPublicKey": "b7b46c08c24d0f91df5387f84b068ec67b8bfff8f7f4762631894fce4aff6c75",
      "signature": "aa413208c32d00b89895049ff21797048fa41c1b2ffc866900ffd97570f8d87e852c87074ed77c6b914f47449ba3f9d6dca99874d9f235ee4c1c83d1d81b6e07",
      "id": "5534571359943011068"
    },
		{
			"type": 2,
			"amount": 0,
			"fee": 0,
			"timestamp": 0,
			"recipientId": null,
			"senderId": "13689350125727268512L",
			"senderPublicKey": "8b3aa957ff8806a8f746acc579385fbf1296de9a604ac99917129f2faf937f1b",
			"asset": {
				"delegate": {
					"username": "genesisDelegate51"
				}
			},
			"signature": "d04ad75f229cbd93570612b7586ea5c13f44a26e9cfad7875580499bc9bac03811f1990cdf6a7b7f76cb1826473224334eabd3ac9b3ddcc39f3852e836956404",
			"id": "9198061231590533593"
		},

		...

		{
      "type": 3,
      "amount": 0,
      "fee": 0,
      "timestamp": 0,
      "recipientId": "6722322622037743544L",
      "senderId": "6722322622037743544L",
      "senderPublicKey": "3ed4d689ced148a97017e2f611b5c4aa28de1564a92fca8234d32290319dbdb3",
      "asset": {
        "votes": [
          "+3319e5bb7b26eda2f3ba91d55536e8260b58bb37b968233823c2ba588200459f",        
        ]
      },
      "signature": "96e1da0134268b02981292b1235dbc07c7dc0acdd348f15a89bc0617bc1361023a8445414843e54d429fa3380f46da9063ed0f4f549e39ae79efef5262301b00",
      "id": "10175549538740098435"
    }
    ...
  ]
}
```

这些的字段，我们在上面的数据库表里已经列出，下面看看几个关键数据：

3行：在创世区块设定初始代币总量，这里是1亿;
1757行：创世区块高度为1;
12行：区块必须包含交易，这里是3种类型的交易，之前分析过，它们分别是转账交易、受托人交易和投票交易。第1个转账交易，把初始区块的代币全部转到了另一个账户，这在实际的生成环境，特别是在ICO（预售）之后，可以直接转给参与众筹的实际用户。所以，创世区块有其非常实际的意义。

（2）同步区块

新建的网络节点，以及那些中途停机的节点，都需要先同步缺失的区块，确保本地有一个完整区块链副本，然后才可以创建新区块。我们可以先设想一下，同步的时机是什么？软件启动过程为`软件启动 -> 节点联网 -> 同步区块 -> 启动完成（开始工作）`，这里，当联网成功之后，就应该立刻检查区块链是否完整，不然下一步工作没法开始。

上述过程存在两个事件，一个是网络节点加载完成事件，一个是区块链加载完成事件。这里存在两种设计方案，第一种是通过事件触发同步区块，当前一事件结束时开始后一事件。这么做思路上没有问题，但是把区块链同步当成了变动的事件，复杂性明显提高了。另一种是，同步区块事件是与软件启动相关的，是软件初始化过程中的一部分，不需要与网络节点联网等其他问题纠缠在一起，这样一来，上面的过程在初始化过程中即可完成，简化很多。亿书就是采用的后者，所以不要滥用事件循环（关于事件循环请看本书开发实践中的相关内容）。

```
// app.js文件
...
ready: ['modules', 'bus', function (cb, scope) {
	// 435行
	scope.bus.message("bind", scope.modules);
	cb();
}]
```

我们在《入口程序app.js解读》一章里解读了app.js文件，但是并不详细，仅仅梳理了程序的大致流程。这里重新提及，专注于区块链同步的问题，这在具体开发过程中，是很正常的增量开发的思路。

app.js文件 435行: 这里触发了自定义的“bind”事件（与Node.js自己的事件处理方式不同），会执行所有模块里的“onBind()”方法。大部分模块里的“onBind()”方法仅仅初始化了实例化的模块等变量，唯独`loader.js`模块，执行了下面的代码：

```
// modules/loader.js文件
Loader.prototype.onBind = function (scope) {
	modules = scope;
	// 534行
	private.loadBlockChain();
};
```

modules/loader.js文件534行 `private.loadBlockChain` 方法就是用来加载区块链的，内容如下：

```
// modules/loader.js文件
private.loadBlockChain = function () {
	var offset = 0, limit = library.config.loading.loadPerIteration;
	var verify = library.config.loading.verifyOnLoading;

	function load(count) {
		verify = true;
		private.total = count;

		library.logic.account.removeTables(function (err) {
			if (err) {
				throw err;
			} else {
				library.logic.account.createTables(function (err) {
					if (err) {
						throw err;
					} else {
						async.until(
							function () {
								return count < offset;
							}, function (cb) {
								library.logger.info('Current ' + offset);
								setImmediate(function () {
									modules.blocks.loadBlocksOffset(limit, offset, verify, function (err, lastBlockOffset) {
										if (err) {
											return cb(err);
										}

										offset = offset + limit;
										private.loadingLastBlock = lastBlockOffset;

										cb();
									});
								});
							}, function (err) {
								if (err) {
									library.logger.error('loadBlocksOffset', err);
									if (err.block) {
										library.logger.error('Blockchain failed at ', err.block.height);
										modules.blocks.simpleDeleteAfterBlock(err.block.id, function (err, res) {
											library.logger.error('Blockchain clipped');
											library.bus.message('blockchainReady');
										});
									}
								} else {
									library.logger.info('Blockchain ready');
									library.bus.message('blockchainReady');
								}
							}
						);
					}
				});
			}
		});
	}

	library.logic.account.createTables(function (err) {
		if (err) {
			throw err;
		} else {
			library.dbLite.query("select count(*) from mem_accounts where blockId = (select id from blocks where numberOfTransactions > 0 order by height desc limit 1)", {'count': Number}, function (err, rows) {
				if (err) {
					throw err;
				}

				var reject = !(rows[0].count);

				modules.blocks.count(function (err, count) {
					if (err) {
						return library.logger.error('Failed to count blocks', err);
					}

					library.logger.info('Blocks ' + count);

					// Check if previous loading missed
					if (reject || verify || count == 1) {
						load(count);
					} else {
						library.dbLite.query(
							"UPDATE mem_accounts SET u_isDelegate=isDelegate,u_secondSignature=secondSignature,u_username=username,u_balance=balance,u_delegates=delegates,u_contacts=contacts,u_followers=followers,u_multisignatures=multisignatures"
							, function (err, updated) {
								if (err) {
									library.logger.error(err);
									library.logger.info("Unable to load without verifying, clearing accounts from database and loading");
									load(count);
								} else {
									library.dbLite.query("select a.blockId, b.id from mem_accounts a left outer join blocks b on b.id = a.blockId where b.id is null", {}, ['a_blockId', 'b_id'], function (err, rows) {
										if (err || rows.length > 0) {
											library.logger.error(err || "Encountered missing block, looks like node went down during block processing");
											library.logger.info("Unable to load without verifying, clearing accounts from database and loading");
											load(count);
										} else {
											// Load delegates
											library.dbLite.query("SELECT lower(hex(publicKey)) FROM mem_accounts WHERE isDelegate=1", ['publicKey'], function (err, delegates) {
												if (err || delegates.length === 0) {
													library.logger.error(err || "No delegates, reload database");
													library.logger.info("Unable to load without verifying, clearing accounts from database and loading");
													load(count);
												} else {
													modules.blocks.loadBlocksOffset(1, count, verify, function (err, lastBlock) {
														if (err) {
															library.logger.error(err || "Unable to load last block");
															library.logger.info("Unable to load without verifying, clearing accounts from database and loading");
															load(count);
														} else {
															modules.blocks.loadLastBlock(function (err, block) {
																if (err) {
																	return load(count);
																}
																private.lastBlock = block;
																library.logger.info('Blockchain ready');
																library.bus.message('blockchainReady');
															});
														}
													});
												}
											});
										}
									});
								}
							});
					}

				});
			});
		}
	});

};
```

（3）验证区块


（4）创建区块

* 处理区块头信息，并产生区块；
* 收集整理交易，写入（关联）区块；
* 把新产生的区块写入区块链；
* 解决区块链分叉。

区块头信息处理

产生c结尾的地址：

```
// logic/block.js 20行
private.getAddressByPublicKey = function (publicKey) {
	var publicKeyHash = crypto.createHash('sha256').update(publicKey, 'hex').digest();
	var temp = new Buffer(8);
	for (var i = 0; i < 8; i++) {
		temp[i] = publicKeyHash[7 - i];
	}

	var address = bignum.fromBuffer(temp).toString() + "C";
	return address;
}

// 上面的方法，在312行dbRead函数里调用，
generatorId: private.getAddressByPublicKey(raw.b_generatorPublicKey),
```

## 总结

## 链接

## 参考

[从数据库发展规律看区块链技术](http://chainb.com/?P=Cont&id=33)

[区块链](http://www.8btc.com/what-is-blockchain)

[关于比特币硬分叉和软分叉的争议](http://www.8btc.com/on-consensus-and-forks)

[以太坊软分叉失败，硬分叉成功](http://8btc.com/thread-36657-1-1.html)

[blocks-class.png]: ../styles/images/modules/blocks/blocks-class.png
[blocks-activity.png]: ../styles/images/modules/blocks/blocks-activity.png
[stack-drawers.png]: ../styles/images/third/drawers2.png
[blocks-database.png]: ../styles/images/modules/blocks/blocks-database.png
