进行中...

# 交易

## 前言

我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移，因此，加密货币的核心就是`交易`，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。

这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结一个交易的生命周期及操作流程，把我们在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。

## 源码

transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js

transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js

transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js

## 类图

![transactions-clase.png][]

## 流程图

这里把各种情况集中到一起来讨论，可以对`交易`有个全局性的把握。

![transactions-activity.png][]

## 解读

#### 关于交易



#### 亿书交易类型

目前的交易类型包括14种（但并不代表全部，下一步会有更多扩展），分别是：

```
// helpers/transaction-types.js
module.exports = {
	SEND : 0,
	SIGNATURE : 1,
	DELEGATE : 2,
	VOTE : 3,
	USERNAME : 4,
	FOLLOW : 5,
	MULTI: 6,
	DAPP: 7,
	IN_TRANSFER: 8,
	OUT_TRANSFER: 9,
	ARTICALE : 10,
	EBOOK: 11，
  BUY: 12，
	READ: 13
}
```

其中，

`SEND`是最基本的转账交易，`SIGNATURE`是上一篇提到的“签名”交易，`DELEGATE`是注册为受托人，`VOTE`是投票，`USERNAME`是注册用户别名，`FOLLOW`是添加联系人，`MULTI`是注册多重签名帐号，`DAPP`是侧链应用，`IN_TRANSFER`是转入Aapp资金，`OUT_TRANSFER`转出Aapp资金，这些是现有版本已经完成的功能。

`ARTICALE`是发布文章，`EBOOK`是发布电子书，`BUY`是购买（电子书或其他商品），`READ`是付费阅读（电子书等，不能下载，价格由作者自由设置，可以免费），这些功能会逐步添加。

这些交易，除了`SEND`转账交易外，其他的交易类型，我们暂且称它们为功能性交易。

#### 交易基本流程

亿书交易类型尽管多样，但是交易的基本逻辑是相似的。加密货币的整体设计就是为了安全的交易，整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。完整实现一笔交易，需要这样几个步骤：

（1）明确发起交易者

交易是人类行为，必然涉及到甲乙双方和交易数量。甲方必须是主动发起交易的有效用户（有合法亿书币客户端地址，需要验证），是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法客户端地址的用户（需要验证），也可以是亿书系统本身（功能性交易），是亿书币的接收方（需要通过类型区分对待）。

简单的一句话就是：谁与谁交易了多少钱。如此以来，一笔交易必须包含如下字段：

* 交易类型。代码里表示为 type: TransactionTypes.SEND;
* 支付帐号。代码里指的是 sender: account;
* 接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername;
* 交易数量。代码里指的是 amount: body.amount。

如`modules/transactions.js`文件里的763和800行（见下面转账交易部分的代码）

（2）验证交易合法性

这个很好理解，不过最为繁琐，主要涉及到：发起交易的用户是否存在、是否已登录、是否有权限、余额是否足够，都要逐个验证;接受方用户地址是否合法等等。

（3）记录交易时间戳

一笔合法交易，要准确记录它的交易时间。

（4）广播到网络，并写入区块

前面我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析`转账交易`来学习整个交易、验证的过程。

#### 转账交易分析

代码实现在`modules/transactions.js`文件里，主要Api如下：

```
// 148行
router.map(shared, {
  "get /": "getTransactions",
  "get /get": "getTransaction",
  "get /unconfirmed/get": "getUnconfirmedTransaction",
  "get /unconfirmed": "getUnconfirmedTransactions",
  "put /": "addTransactions"
});

// 160行
library.network.app.use('/api/transactions', router);
```

解析一下，就是：

```
get /api/transactions/ -> shared.getTransactions
get /api/transactions/get -> shared.getTransaction
get /api/transactions/unconfirmed/get -> shared.getUnconfirmedTransaction
get /api/transactions/unconfirmed -> shared.getUnconfirmedTransactions
put /api/transactions/ -> shared.addTransactions
```

我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，`put /api/transactions/`，对应方法`shared.addTransactions`，完整代码如下：

```
// 652行
shared.addTransactions = function (req, cb) {
	var body = req.body;
	// 654行 验证数据格式
	library.scheme.validate(body, {
		type: "object",		
		properties: {
			secret: {
				type: "string",
				minLength: 1,
				maxLength: 100
			},
			amount: {
				type: "integer",
				minimum: 1,
				maximum: constants.totalAmount
			},
			recipientId: {
				type: "string",
				minLength: 1
			},
			publicKey: {
				type: "string",
				format: "publicKey"
			},
			secondSecret: {
				type: "string",
				minLength: 1,
				maxLength: 100
			},
			multisigAccountPublicKey: {
				type: "string",
				format: "publicKey"
			}
		},
		required: ["secret", "amount", "recipientId"]
	}, function (err) {		
		if (err) {
			return cb(err[0].message);
		}

		var hash = crypto.createHash('sha256').update(body.secret, 'utf8').digest();
		var keypair = ed.MakeKeypair(hash);

		// 694行 验证公钥信息
		if (body.publicKey) {
			if (keypair.publicKey.toString('hex') != body.publicKey) {
				return cb("Invalid passphrase");
			}
		}

		var query = {};

		// 乙方（接收方）地址转换
		var isAddress = /^[0-9]+[L|l]$/g;
		if (isAddress.test(body.recipientId)) {
			query.address = body.recipientId;
		} else {
			query.username = body.recipientId;
		}

		// 加入平衡队列（balancesSequence）
		library.balancesSequence.add(function (cb) {
			// 验证乙方（接收方）用户合法性
			modules.accounts.getAccount(query, function (err, recipient) {
				if (err) {
					return cb(err.toString());
				}
				if (!recipient && query.username) {
					return cb("Recipient not found");
				}

				var recipientId = recipient ? recipient.address : body.recipientId;
				var recipientUsername = recipient ? recipient.username : null;

				// 是多重签名帐号
				if (body.multisigAccountPublicKey && body.multisigAccountPublicKey != keypair.publicKey.toString('hex')) {
					// 验证多重签名
					modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}
						// 帐号不存在
						if (!account || !account.publicKey) {
							return cb("Multisignature account not found");
						}
						// 帐号存在，但并没有开启多重签名帐号
						if (!account.multisignatures || !account.multisignatures) {
							return cb("Account does not have multisignatures enabled");
						}
						// 帐号存在、也是多重签名帐号，但不属于该多重签名帐号组
						if (account.multisignatures.indexOf(keypair.publicKey.toString('hex')) < 0) {
							return cb("Account does not belong to multisignature group");
						}

						// 验证甲方（发送方）用户合法性
						modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {
							if (err) {
								return cb(err.toString());
							}

							if (!requester || !requester.publicKey) {
								return cb("Invalid requester");
							}

							// 验证甲方支付密码（有支付密码必须提供），这里是bug：没有验证支付密码是否相符
							if (requester.secondSignature && !body.secondSecret) {
								return cb("Invalid second passphrase");
							}

							// 甲乙方不能是一个人
							if (requester.publicKey == account.publicKey) {
								return cb("Invalid requester");
							}

							var secondKeypair = null;

							if (requester.secondSignature) {
								var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
								secondKeypair = ed.MakeKeypair(secondHash);
							}

							try {
								// 763行 交易合法，创建交易记录 -> 进入logic/transaction.js
								var transaction = library.logic.transaction.create({
									type: TransactionTypes.SEND,
									amount: body.amount,
									sender: account,
									recipientId: recipientId,
									recipientUsername: recipientUsername,
									keypair: keypair,
									requester: keypair,
									secondKeypair: secondKeypair
								});
							} catch (e) {
								return cb(e.toString());
							}
							// 把交易放入队列集中处理（广播交易，写入数据库等）-> receiveTransactions -> processUnconfirmedTransaction
							modules.transactions.receiveTransactions([transaction], cb);
						});
					});
				} else {
					// 非多重签名帐号
					modules.accounts.getAccount({publicKey: keypair.publicKey.toString('hex')}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}
						if (!account || !account.publicKey) {
							return cb("Invalid account");
						}

						if (account.secondSignature && !body.secondSecret) {
							return cb("Invalid second passphrase");
						}

						var secondKeypair = null;

						if (account.secondSignature) {
							var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
							secondKeypair = ed.MakeKeypair(secondHash);
						}

						try {
							// 800行
							var transaction = library.logic.transaction.create({
								type: TransactionTypes.SEND,
								amount: body.amount,
								sender: account,
								recipientId: recipientId,
								recipientUsername: recipientUsername,
								keypair: keypair,
								secondKeypair: secondKeypair
							});
						} catch (e) {
							return cb(e.toString());
						}
						modules.transactions.receiveTransactions([transaction], cb);
					});
				}
			});
		}, function (err, transaction) {
			if (err) {
				return cb(err.toString());
			}

			cb(null, {transactionId: transaction[0].id});
		});
	});
}
```

下面是`logic/transaction.js`文件的`create`方法，

```
// 26行
Transaction.prototype.create = function (data) {
	if (!private.types[data.type]) {
		throw Error('Unknown transaction type ' + data.type);
	}

	if (!data.sender) {
		throw Error("Can't find sender");
	}

	if (!data.keypair) {
		throw Error("Can't find keypair");
	}

	var trs = {
		type: data.type,
		amount: 0,
		senderPublicKey: data.sender.publicKey,
		requesterPublicKey: data.requester ? data.requester.publicKey.toString('hex') : null,
		timestamp: slots.getTime(),
		asset: {}
	};

	trs = private.types[trs.type].create.call(this, data, trs);
	trs.signature = this.sign(data.keypair, trs);

	if (data.sender.secondSignature && data.secondKeypair) {
		trs.signSignature = this.sign(data.secondKeypair, trs);
	}

	trs.id = this.getId(trs);

	trs.fee = private.types[trs.type].calculateFee.call(this, trs, data.sender) || false;

	return trs;
}
```
## 参考

[transactions-clase.png]: ../styles/images/modules/transactions/transactions-class.png
