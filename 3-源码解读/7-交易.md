进行中...

# 交易

## 前言

我们在第一部分《了解加密货币》里说过，加密货币是“利益”转移的程序化，其核心目标是保证数字财富或价值安全、透明、快速的转移，因此，加密货币的核心就是`交易`，加密解密、P2P网络、区块链等一系列技术都是围绕交易展开的。

这一篇，我们就来研究亿书提供的交易类型及代码实现，集中总结一个交易的生命周期及操作流程，把我们在《地址》和《签名和多重签名》里故意漏掉的判断逻辑补充完整。

## 源码

transaction-types.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/helpers/transaction-types.js

transaction.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/logic/transaction.js

transactions.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/transactions.js

## 类图

![transactions-clase.png][]

## 解读

#### 交易的本质

从经济学角度来说，交易就是一种价值交换。在《精通比特币》（见参考）一书里，作者是这样定义比特币交易的：简单地说，交易是指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”就是一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。

把这些重要信息汇总到一起，既让用户容易理解，又要体现加密货币特点，可以这样定义：

> 加密货币的交易是指人们通过加密货币网络，把加密货币进行有效转移，
> 并把交易数据由点对点网络保存到区块链的过程。

即便简化定义，对于刚刚接触加密货币的小伙伴来说，理解起来，还是有点费解。通常，大家喜欢把加密货币的交易，比做成纸质支票。与支票相似，一笔加密货币交易其实是一个有着货币转移目的的工具，这个工具只有在交易被执行时才会在金融体系中体现，而且交易发起人并不一定是签署该笔交易的人。

交易可以被任何人在线上或线下创建，即便创建这笔交易的人不是这个账户的授权签字人。这一点非常好理解，假如有一张空的纸质支票，我们可以自己填写，也可以找人填写，最后只要有支付权限的领导签名，支票就能生效，就可以兑付。加密货币也是如此，无论谁创建的加密货币交易，只要被资金所有者（们）数字签名，交易就能实现。

交易只是一些经过加密处理的字节码，不含任何机密信息、私钥或密码，可被任何潜在的便利网络公开传播，甚至可以被处理成二维码、表情符号、短信等形式传播。只要这笔交易能进入加密货币网络，那么发送者并不需要信任用来传播该笔交易的任何一个节点。相应地，这些节点不需要信任发送者，也不用建立发送者的“身份档案”。相反，电子商务网站的交易，包含敏感信息，而且依赖加密网络连接完成信息传输。

因此，本质上，加密货币交易是价值所有权的转移，而不是价值转移。加密货币总量就是那些，从始至终都不会变化，人为丢失的是人类使用流通的部分，总量不会丢失。记录加密货币总量的区块链就那一条，这个链条可以越来越长，越来越大，但是增长的仅仅是交易的信息，即价值所有权变更信息。用个不慎确切的比喻，加密货币就像一列永不停息的火车，上下的是人次，固定的是座位，您只有在自己的人生旅途中才拥有某个座位的所有权（使用权）。

#### 交易生命周期

交易是加密货币系统中最重要的部分，系统中任何其他的部分都是为了确保交易可以被生成、能在网络中得以传播和通过验证，并最终写入全球交易总账簿（区块链）。因此，从开发设计角度考虑，完成一笔加密货币交易必须经历下面的过程：

1. 生成一笔交易。这里是指包含交易双方加密货币地址、数量和时间戳等信息的合法交易数据;
2. 广播到网络;
3. 验证交易合法性;
4. 写入区块链。

下面，我们来详细阅读分析亿书的交易是如何实现的。

#### 亿书交易类型

目前的交易类型包括14种（但并不代表全部，下一步会有更多扩展），分别是：

```
// helpers/transaction-types.js
module.exports = {
	SEND : 0,
	SIGNATURE : 1,
	DELEGATE : 2,
	VOTE : 3,
	USERNAME : 4,
	FOLLOW : 5,
	MULTI: 6,
	DAPP: 7,
	IN_TRANSFER: 8,
	OUT_TRANSFER: 9,
	ARTICALE : 10,
	EBOOK: 11，
  BUY: 12，
	READ: 13
}
```

其中，

`SEND`是最基本的转账交易，`SIGNATURE`是上一篇提到的“签名”交易，`DELEGATE`是注册为受托人，`VOTE`是投票，`USERNAME`是注册用户别名，`FOLLOW`是添加联系人，`MULTI`是注册多重签名帐号，`DAPP`是侧链应用，`IN_TRANSFER`是转入Aapp资金，`OUT_TRANSFER`转出Aapp资金，这些是现有版本已经完成的功能。

`ARTICALE`是发布文章，`EBOOK`是发布电子书，`BUY`是购买（电子书或其他商品），`READ`是付费阅读（电子书等，不能下载，价格由作者自由设置，可以免费），这些功能会逐步添加。

这些交易，除了`SEND`转账交易外，其他的交易类型，我们暂且称它们为功能性交易（在比特币的圈子里，有人称为伪交易）。

#### 交易基本流程

亿书交易类型尽管多样，但是交易的基本逻辑是相似的。加密货币的整体设计就是为了安全的交易，整个加密货币都是交易逻辑的有效组成部分，要比传统电子商务网站复杂的多，但与交易直接相关的代码，却又非常简单清晰。结合加密货币交易实现基本需求，完整实现一笔交易，亿书需要这样几个步骤：

（1）生成交易数据

交易是人类行为，必然涉及到甲乙双方（货币发送者和接收者，我们用甲乙方来代替，下文同）和交易数额。甲方是主动发起交易的有效用户，是亿书币的支付方，是交易的支付来源。乙方比较灵活，可以是另一个有合法客户端地址的用户，也可以是亿书系统本身（功能性交易），是亿书币的接收方（需要通过独立的类型字段区分对待）。

简单的一句话就是：谁与谁交易了多少钱。如此以来，一笔交易必须包含如下字段：

* 交易类型。代码里表示为 type: TransactionTypes.SEND;
* 支付帐号。代码里指的是 sender: account;
* 接受帐号。代码里指的是 recipientId: recipientId, 如果用的是别名地址，就是 recipientUsername: recipientUsername;
* 交易数量。代码里指的是 amount: body.amount。

如`modules/transactions.js`文件里的763和800行（见下面转账交易部分的代码）

整理数据的另一个重要过程，就是检验这些交易数据的正确性。这个很好理解，如果一个人胡乱填写的接受地址，也能把币发送出去，那就笑话了。过程较为繁琐，主要涉及到：发起交易的用户是否存在、密钥是否正确、是否多重签名帐号、是否有支付密码，以及接受方用户地址是否合法等，都要逐个检验。

（2）给合法交易签名

一笔合法交易，要准确记录它的交易时间戳。同时，还要使用甲乙方的公钥签名，确保交易所属。交易ID也是包含丰富加密信息的字段，需要复杂的生成过程。

（3）验证交易合法性



（4）广播到点对点网络，并写入区块链

没有中心服务器，必须借助点对点网络，把交易数据写入分布式公共账本——区块链，保证交易数据永远无法篡改，而且可以轻松查询追溯。

这在中心化的服务器上，为了应对个别交易摩擦，保证交易记录可追溯，要采取更多的技术手段，记录更多的数据字段，意味着要保持大量数据冗余，付出更多资金成本。

上述过程，亿书完成一笔交易的完整流程图，如图：

![transactions-activity.png][]

#### 转账交易分析

前面我们接触到几种交易类型，比如：注册别名地址和多重签名地址，不过并没有研究具体的交易过程，下面通过分析`转账交易`来学习整个交易、验证的过程。

代码实现在`modules/transactions.js`文件里，主要Api如下：

```
// 148行
router.map(shared, {
  "get /": "getTransactions",
  "get /get": "getTransaction",
  "get /unconfirmed/get": "getUnconfirmedTransaction",
  "get /unconfirmed": "getUnconfirmedTransactions",
  "put /": "addTransactions"
});

// 160行
library.network.app.use('/api/transactions', router);
```

解析一下，就是：

```
get /api/transactions/ -> shared.getTransactions
get /api/transactions/get -> shared.getTransaction
get /api/transactions/unconfirmed/get -> shared.getUnconfirmedTransaction
get /api/transactions/unconfirmed -> shared.getUnconfirmedTransactions
put /api/transactions/ -> shared.addTransactions
```

我们仍然把读取数据的Api放一放，因为他们很简单，重点掌握写数据的操作，`put /api/transactions/`，对应方法`shared.addTransactions`，完整代码如下：

```
// 652行
shared.addTransactions = function (req, cb) {
	var body = req.body;
	library.scheme.validate(body, {
		type: "object",
		properties: {
			secret: {
				type: "string",
				minLength: 1,
				maxLength: 100
			},
			amount: {
				type: "integer",
				minimum: 1,
				maximum: constants.totalAmount
			},
			recipientId: {
				type: "string",
				minLength: 1
			},
			publicKey: {
				type: "string",
				format: "publicKey"
			},
			secondSecret: {
				type: "string",
				minLength: 1,
				maxLength: 100
			},
			multisigAccountPublicKey: {
				type: "string",
				format: "publicKey"
			}
		},
		//
		required: ["secret", "amount", "recipientId"]
	}, function (err) {
		// 验证数据格式
		if (err) {
			return cb(err[0].message);
		}

		// 验证密码信息
		var hash = crypto.createHash('sha256').update(body.secret, 'utf8').digest();
		var keypair = ed.MakeKeypair(hash);

		if (body.publicKey) {
			if (keypair.publicKey.toString('hex') != body.publicKey) {
				return cb("Invalid passphrase");
			}
		}

		var query = {};

		// 乙方（接收方）地址转换
		var isAddress = /^[0-9]+[L|l]$/g;
		if (isAddress.test(body.recipientId)) {
			query.address = body.recipientId;
		} else {
			query.username = body.recipientId;
		}

		library.balancesSequence.add(function (cb) {
			// 验证乙方用户合法性
			modules.accounts.getAccount(query, function (err, recipient) {
				if (err) {
					return cb(err.toString());
				}
				if (!recipient && query.username) {
					return cb("Recipient not found");
				}

				var recipientId = recipient ? recipient.address : body.recipientId;
				var recipientUsername = recipient ? recipient.username : null;

				// 验证甲方（发送方）用户合法性
				if (body.multisigAccountPublicKey && body.multisigAccountPublicKey != keypair.publicKey.toString('hex')) {
					// 验证多重签名
					modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}

						if (!account || !account.publicKey) {
							return cb("Multisignature account not found");
						}

						if (!account || !account.multisignatures) {
							return cb("Account does not have multisignatures enabled");
						}

						if (account.multisignatures.indexOf(keypair.publicKey.toString('hex')) < 0) {
							return cb("Account does not belong to multisignature group");
						}

						// 接着验证甲方（发送方）用户合法性
						modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {
							if (err) {
								return cb(err.toString());
							}

							if (!requester || !requester.publicKey) {
								return cb("Invalid requester");
							}

							// 验证甲方支付密码
							if (requester.secondSignature && !body.secondSecret) {
								return cb("Invalid second passphrase");
							}

							//
							if (requester.publicKey == account.publicKey) {
								return cb("Invalid requester");
							}

							var secondKeypair = null;

							if (requester.secondSignature) {
								var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
								secondKeypair = ed.MakeKeypair(secondHash);
							}

							try {
								// 763行
								var transaction = library.logic.transaction.create({
									type: TransactionTypes.SEND,
									amount: body.amount,
									sender: account,
									recipientId: recipientId,
									recipientUsername: recipientUsername,
									keypair: keypair,
									requester: keypair,
									secondKeypair: secondKeypair
								});
							} catch (e) {
								return cb(e.toString());
							}
							modules.transactions.receiveTransactions([transaction], cb);
						});
					});
				} else {
					// 直接验证甲方（发送方）用户合法性
					modules.accounts.getAccount({publicKey: keypair.publicKey.toString('hex')}, function (err, account) {
						if (err) {
							return cb(err.toString());
						}
						if (!account || !account.publicKey) {
							return cb("Invalid account");
						}

						if (account.secondSignature && !body.secondSecret) {
							return cb("Invalid second passphrase");
						}

						var secondKeypair = null;

						if (account.secondSignature) {
							var secondHash = crypto.createHash('sha256').update(body.secondSecret, 'utf8').digest();
							secondKeypair = ed.MakeKeypair(secondHash);
						}

						try {
							// 800行
							var transaction = library.logic.transaction.create({
								type: TransactionTypes.SEND,
								amount: body.amount,
								sender: account,
								recipientId: recipientId,
								recipientUsername: recipientUsername,
								keypair: keypair,
								secondKeypair: secondKeypair
							});
						} catch (e) {
							return cb(e.toString());
						}
						modules.transactions.receiveTransactions([transaction], cb);
					});
				}
			});
		}, function (err, transaction) {
			if (err) {
				return cb(err.toString());
			}

			cb(null, {transactionId: transaction[0].id});
		});
	});
}
```


```
Transactions.prototype.processUnconfirmedTransaction = function (transaction, broadcast, cb) {
	modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) {
		function done(err) {
			if (err) {
				return cb(err);
			}

			private.addUnconfirmedTransaction(transaction, sender, function (err) {
				if (err) {
					return cb(err);
				}

				library.bus.message('unconfirmedTransaction', transaction, broadcast);

				cb();
			});
		}

		if (err) {
			return done(err);
		}

		if (transaction.requesterPublicKey && sender && sender.multisignatures && sender.multisignatures.length) {
			modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, function (err, requester) {
				if (err) {
					return done(err);
				}

				if (!requester) {
					return cb("Invalid requester");
				}

				library.logic.transaction.process(transaction, sender, requester, function (err, transaction) {
					if (err) {
						return done(err);
					}

					// Check in confirmed transactions
					if (private.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || private.doubleSpendingTransactions[transaction.id]) {
						return cb("Transaction already exists");
					}

					library.logic.transaction.verify(transaction, sender, done);
				});
			});
		} else {
			library.logic.transaction.process(transaction, sender, function (err, transaction) {
				if (err) {
					return done(err);
				}

				// Check in confirmed transactions
				if (private.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || private.doubleSpendingTransactions[transaction.id]) {
					return cb("Transaction already exists");
				}

				library.logic.transaction.verify(transaction, sender, done);
			});
		}
	});
}
```

## 参考

[精通比特币（英文）](https://github.com/imfly/bitcoinbook)

[精通比特币（中文）](http://book.8btc.com/master_bitcoin)

[transactions-clase.png]: ../styles/images/modules/transactions/transactions-class.png
[transactions-activity.png]: ../styles/images/modules/transactions/transactions-activity.png
